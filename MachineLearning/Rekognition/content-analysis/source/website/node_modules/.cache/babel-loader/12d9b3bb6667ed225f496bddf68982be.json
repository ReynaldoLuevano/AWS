{"remainingRequest":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/thread-loader/dist/cjs.js!/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/babel-loader/lib/index.js!/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/cache-loader/dist/cjs.js??ref--0-0!/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/src/components/TextDetection.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/src/components/TextDetection.vue","mtime":1759685740382},{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/babel.config.js","mtime":1759685740381},{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1759686089217},{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/thread-loader/dist/cjs.js","mtime":1759686089126},{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/babel-loader/lib/index.js","mtime":1759686089251},{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/cache-loader/dist/cjs.js","mtime":1759686089217},{"path":"/home/reynaldo/Documents/AWS/MachineLearning/Rekognition/content-analysis-on-aws/source/website/node_modules/vue-loader/lib/index.js","mtime":1759686084280}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9yZWdlbmVyYXRvciBmcm9tICIvaG9tZS9yZXluYWxkby9Eb2N1bWVudHMvQVdTL01hY2hpbmVMZWFybmluZy9SZWtvZ25pdGlvbi9jb250ZW50LWFuYWx5c2lzLW9uLWF3cy9zb3VyY2Uvd2Vic2l0ZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcmVnZW5lcmF0b3IuanMiOwppbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSAiL2hvbWUvcmV5bmFsZG8vRG9jdW1lbnRzL0FXUy9NYWNoaW5lTGVhcm5pbmcvUmVrb2duaXRpb24vY29udGVudC1hbmFseXNpcy1vbi1hd3Mvc291cmNlL3dlYnNpdGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanMiOwppbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gIi9ob21lL3JleW5hbGRvL0RvY3VtZW50cy9BV1MvTWFjaGluZUxlYXJuaW5nL1Jla29nbml0aW9uL2NvbnRlbnQtYW5hbHlzaXMtb24tYXdzL3NvdXJjZS93ZWJzaXRlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyI7CmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gIi9ob21lL3JleW5hbGRvL0RvY3VtZW50cy9BV1MvTWFjaGluZUxlYXJuaW5nL1Jla29nbml0aW9uL2NvbnRlbnQtYW5hbHlzaXMtb24tYXdzL3NvdXJjZS93ZWJzaXRlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hcC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5jb25zdHJ1Y3Rvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzbmV4dC5pdGVyYXRvci5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IuZm9yLWVhY2guanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIudXJsLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC50by1qc29uLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmpzIjsKLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBMb2FkaW5nIGZyb20gJ0AvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZSc7CmltcG9ydCB7IG1hcFN0YXRlIH0gZnJvbSAndnVleCc7Ci8vIFRPRE86IFRoaW5rIGFib3V0IGhvdyB0byBoYW5kbGUgIkxJTkUiIGRldGVjdGlvbiB0eXBlcywgbWF5YmUgYW5vdGhlciBjb21wb25lbnQ/IG9yIGEgZHJvcCBkb3duIHRvIGZpbHRlciB3b3JkcyAvIGxpbmVzCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAiVGV4dERldGVjdGlvbiIsCiAgY29tcG9uZW50czogewogICAgTG9hZGluZzogTG9hZGluZwogIH0sCiAgcHJvcHM6IHsKICAgIG1lZGlhVHlwZTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICIiCiAgICB9CiAgfSwKICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY3VybENvbW1hbmQ6ICcnLAogICAgICBzZWFyY2hRdWVyeTogJycsCiAgICAgIHNob3dFbGFzdGljc2VhcmNoQXBpUmVxdWVzdDogZmFsc2UsCiAgICAgIENvbmZpZGVuY2U6IDkwLAogICAgICBoaWdoX2NvbmZpZGVuY2VfZGF0YTogW10sCiAgICAgIGVsYXN0aWNzZWFyY2hfZGF0YTogW10sCiAgICAgIGJveGVzX2F2YWlsYWJsZTogW10sCiAgICAgIGNvdW50X2Rpc3RpbmN0X3dvcmRzOiAwLAogICAgICBjb3VudF93b3JkczogMCwKICAgICAgLy9jb3VudF9kaXN0aW5jdF9saW5lczogMCwKICAgICAgLy9jb3VudF9saW5lczogMCwKICAgICAgaXNCdXN5OiBmYWxzZSwKICAgICAgb3BlcmF0b3I6ICd0ZXh0RGV0ZWN0aW9uJywKICAgICAgY2FudmFzUmVmcmVzaEludGVydmFsOiB1bmRlZmluZWQsCiAgICAgIHRpbWVzZXJpZXM6IG5ldyBNYXAoKSwKICAgICAgc2VsZWN0ZWRXb3JkOiAnJywKICAgICAgbG93ZXJDb25maWRlbmNlOiBmYWxzZSwKICAgICAgbG93ZXJDb25maWRlbmNlTWVzc2FnZTogJ1RyeSBsb3dlcmluZyBjb25maWRlbmNlIHRocmVzaG9sZCcKICAgIH07CiAgfSwKICBjb21wdXRlZDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtYXBTdGF0ZShbJ3BsYXllciddKSksIHt9LCB7CiAgICBzb3J0ZWRfdW5pcXVlX3dvcmRfZGV0ZWN0aW9uczogZnVuY3Rpb24gc29ydGVkX3VuaXF1ZV93b3JkX2RldGVjdGlvbnMoKSB7CiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gc29ydHMgYW5kIGNvdW50cyB1bmlxdWUgd29yZHMgZm9yIG1vdXNlIG92ZXIgZXZlbnRzIG9uIGJ1dHRvbnMKICAgICAgdmFyIGVzX2RhdGEgPSB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YTsKICAgICAgY29uc29sZS5sb2coZXNfZGF0YSk7CiAgICAgIHZhciB1bmlxdWVfd29yZHMgPSBuZXcgTWFwKCk7CiAgICAgIC8vY29uc3QgdW5pcXVlX2xpbmVzID0gbmV3IE1hcCgpOwogICAgICAvLyBzb3J0IGFuZCBjb3VudCB1bmlxdWUgd29yZHMgZm9yIG1vdXNlIG92ZXIgZXZlbnRzCiAgICAgIGVzX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7CiAgICAgICAgaWYgKHJlY29yZC5UeXBlID09ICdXT1JEJykgewogICAgICAgICAgdW5pcXVlX3dvcmRzLnNldChyZWNvcmQuRGV0ZWN0ZWRUZXh0LCB1bmlxdWVfd29yZHMuZ2V0KHJlY29yZC5EZXRlY3RlZFRleHQpID8gdW5pcXVlX3dvcmRzLmdldChyZWNvcmQuRGV0ZWN0ZWRUZXh0KSArIDEgOiAxKTsKICAgICAgICB9CiAgICAgICAgLy8gaWYgKHJlY29yZC5UZXh0VHlwZSA9PSAnTElORScpIHsKICAgICAgICAvLyAgIHVuaXF1ZV9saW5lcy5zZXQocmVjb3JkLkRldGVjdGVkVGV4dCwgdW5pcXVlX2xpbmVzLmdldChyZWNvcmQuRGV0ZWN0ZWRUZXh0KSA/IHVuaXF1ZV9saW5lcy5nZXQocmVjb3JkLkRldGVjdGVkVGV4dCkgKyAxIDogMSk7CiAgICAgICAgLy8gfQogICAgICAgIGlmIChyZWNvcmQuQm91bmRpbmdCb3gpIHsKICAgICAgICAgIC8vIFNhdmUgdGhpcyB3b3JkIGRldGVjdGlvbiB0byBhIGxpc3Qgb2Ygd29yZHMgdGhhdCBoYXZlIGJvdW5kaW5nIGJveGVzCiAgICAgICAgICB0aGlzLnNhdmVCb3hlZERldGVjdGVkVGV4dChyZWNvcmQuRGV0ZWN0ZWRUZXh0KTsKICAgICAgICB9CiAgICAgIH0uYmluZCh0aGlzKSk7CiAgICAgIHZhciBzb3J0ZWRfdW5pcXVlX3dvcmRzID0gbmV3IE1hcChfdG9Db25zdW1hYmxlQXJyYXkodW5pcXVlX3dvcmRzLmVudHJpZXMoKSkuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgICAgcmV0dXJuIGJbMV0gLSBhWzFdOwogICAgICB9KSk7CiAgICAgIC8vY29uc3Qgc29ydGVkX3VuaXF1ZV9saW5lcyA9IG5ldyBNYXAoWy4uLnVuaXF1ZV9saW5lcy5lbnRyaWVzKCldLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pKTsKICAgICAgLy8gSWYgRWxhc3RpY3NlYXJjaCByZXR1cm5lZCB1bmRlZmluZWQgd29yZHMgdGhlbiBkZWxldGUgdGhlbToKICAgICAgc29ydGVkX3VuaXF1ZV93b3Jkcy5kZWxldGUodW5kZWZpbmVkKTsKICAgICAgLy9zb3J0ZWRfdW5pcXVlX2xpbmVzLmRlbGV0ZSh1bmRlZmluZWQpOwogICAgICB0aGlzLmNvdW50RGV0ZWN0ZWRXb3Jkcyhzb3J0ZWRfdW5pcXVlX3dvcmRzLnNpemUsIGVzX2RhdGEubGVuZ3RoKTsKICAgICAgLy90aGlzLmNvdW50RGV0ZWN0ZWRMaW5lcyhzb3J0ZWRfdW5pcXVlX2xpbmVzLnNpemUsIGVzX2RhdGEubGVuZ3RoKTsKICAgICAgY29uc29sZS5sb2coc29ydGVkX3VuaXF1ZV93b3Jkcyk7CiAgICAgIHJldHVybiBzb3J0ZWRfdW5pcXVlX3dvcmRzOwogICAgfQogIH0pLAogIHdhdGNoOiB7CiAgICAvLyBUaGVzZSB3YXRjaGVzIHVwZGF0ZSB0aGUgbGluZSBjaGFydAogICAgc2VsZWN0ZWRXb3JkOiBmdW5jdGlvbiBzZWxlY3RlZFdvcmQoKSB7CiAgICAgIHRoaXMuY2hhcnREYXRhKCk7CiAgICB9LAogICAgZWxhc3RpY3NlYXJjaF9kYXRhOiBmdW5jdGlvbiBlbGFzdGljc2VhcmNoX2RhdGEoKSB7CiAgICAgIHRoaXMuY2hhcnREYXRhKCk7CiAgICB9CiAgfSwKICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gZGVhY3RpdmF0ZWQoKSB7CiAgICB0aGlzLmJveGVzX2F2YWlsYWJsZSA9IFtdOwogICAgdGhpcy5zZWxlY3RlZFdvcmQgPSAnJzsKICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwpOwogICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgIHZhciBjdHg7CiAgICBpZiAoY2FudmFzKSBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgIGlmIChjdHgpIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKICB9LAogIGFjdGl2YXRlZDogZnVuY3Rpb24gYWN0aXZhdGVkKCkgewogICAgdGhpcy5mZXRjaEFzc2V0RGF0YSgpOwogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHRoaXMuZ2V0Q3VybENvbW1hbmQoKTsKICB9LAogIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7CiAgICB0aGlzLmhpZ2hfY29uZmlkZW5jZV9kYXRhID0gW107CiAgICB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSA9IFtdOwogICAgdGhpcy5jb3VudF9kaXN0aW5jdF93b3JkcyA9IDA7CiAgICB0aGlzLmNvdW50X3dvcmRzID0gMDsKICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwpOwogIH0sCiAgbWV0aG9kczogewogICAgZ2V0Q3VybENvbW1hbmQ6IGZ1bmN0aW9uIGdldEN1cmxDb21tYW5kKCkgewogICAgICB0aGlzLnNlYXJjaFF1ZXJ5ID0gJ0Fzc2V0SWQ6JyArIHRoaXMuJHJvdXRlLnBhcmFtcy5hc3NldF9pZCArICcgQ29uZmlkZW5jZTo+JyArIHRoaXMuQ29uZmlkZW5jZSArICcgT3BlcmF0b3I6JyArIHRoaXMub3BlcmF0b3I7CiAgICAgIC8vIGdldCBjdXJsIGNvbW1hbmQgdG8gc2VhcmNoIGVsYXN0aWNzZWFyY2gKICAgICAgdGhpcy5jdXJsQ29tbWFuZCA9ICdhd3NjdXJsIC1YIEdFVCAtLXByb2ZpbGUgZGVmYXVsdCAtLXNlcnZpY2UgZXMgLS1yZWdpb24gJyArIHRoaXMuQVdTX1JFR0lPTiArICcgXCcnICsgdGhpcy5TRUFSQ0hfRU5EUE9JTlQgKyAnL19zZWFyY2g/cT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc2VhcmNoUXVlcnkpICsgJ1wnJzsKICAgIH0sCiAgICBzYXZlQm94ZWREZXRlY3RlZFRleHQ6IGZ1bmN0aW9uIHNhdmVCb3hlZERldGVjdGVkVGV4dChkZXRlY3RlZFRleHQpIHsKICAgICAgaWYgKCF0aGlzLmJveGVzX2F2YWlsYWJsZS5pbmNsdWRlcyhkZXRlY3RlZFRleHQpKSB7CiAgICAgICAgdGhpcy5ib3hlc19hdmFpbGFibGUucHVzaChkZXRlY3RlZFRleHQpOwogICAgICB9CiAgICB9LAogICAgY291bnREZXRlY3RlZFdvcmRzOiBmdW5jdGlvbiBjb3VudERldGVjdGVkV29yZHModW5pcXVlV29yZENvdW50LCB0b3RhbFdvcmRDb3VudCkgewogICAgICB0aGlzLmNvdW50X2Rpc3RpbmN0X3dvcmRzID0gdW5pcXVlV29yZENvdW50OwogICAgICB0aGlzLmNvdW50X3dvcmRzID0gdG90YWxXb3JkQ291bnQ7CiAgICAgIC8vIHRoaXMuY291bnRfZGlzdGluY3RfbGluZXMgPSB1bmlxdWVMaW5lQ291bnQ7CiAgICAgIC8vIHRoaXMuY291bnRfbGluZXMgPSB0b3RhbExpbmVDb3VudDsKICAgIH0sCiAgICBzYXZlRmlsZTogZnVuY3Rpb24gc2F2ZUZpbGUoKSB7CiAgICAgIHZhciBlbGFzdGljc2VhcmNoX2RhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSk7CiAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2VsYXN0aWNzZWFyY2hfZGF0YV0sIHsKICAgICAgICB0eXBlOiAndGV4dC9wbGFpbicKICAgICAgfSk7CiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnRzJyksCiAgICAgICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTsKICAgICAgYS5kb3dubG9hZCA9ICJkYXRhLmpzb24iOwogICAgICBhLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTsKICAgICAgYS5kYXRhc2V0LmRvd25sb2FkdXJsID0gWyd0ZXh0L2pzb24nLCBhLmRvd25sb2FkLCBhLmhyZWZdLmpvaW4oJzonKTsKICAgICAgZS5pbml0RXZlbnQoJ2NsaWNrJywgdHJ1ZSwgZmFsc2UsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpOwogICAgICBhLmRpc3BhdGNoRXZlbnQoZSk7CiAgICB9LAogICAgdXBkYXRlQ29uZmlkZW5jZTogZnVuY3Rpb24gdXBkYXRlQ29uZmlkZW5jZShldmVudCkgewogICAgICB0aGlzLmlzQnVzeSA9IHRydWU7CiAgICAgIHRoaXMuQ29uZmlkZW5jZSA9IGV2ZW50LnRhcmdldC52YWx1ZTsKICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAidmlkZW8iKSB7CiAgICAgICAgLy8gcmVkcmF3IG1hcmtlcnMgb24gdmlkZW8gdGltZWxpbmUKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLnJlbW92ZUFsbCgpOwogICAgICB9CiAgICAgIHRoaXMuZ2V0Q3VybENvbW1hbmQoKTsKICAgICAgdGhpcy5mZXRjaEFzc2V0RGF0YSgpOwogICAgfSwKICAgIC8vIHVwZGF0ZU1hcmtlcnMgdXBkYXRlcyBtYXJrZXJzIGluIHRoZSB2aWRlbyBwbGF5ZXIgYW5kIGlzIGNhbGxlZCB3aGVuIHNvbWVvbmUgY2xpY2tzIG9uIGEgd29yZCBidXR0b24KICAgIHVwZGF0ZU1hcmtlcnM6IGZ1bmN0aW9uIHVwZGF0ZU1hcmtlcnMod29yZCkgewogICAgICAvLyBjbGVhciBjYW52YXMgZm9yIHJlZHJhd2luZwogICAgICB0aGlzLmJveGVzX2F2YWlsYWJsZSA9IFtdOwogICAgICBjbGVhckludGVydmFsKHRoaXMuY2FudmFzUmVmcmVzaEludGVydmFsKTsKICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICJyZWQiOwogICAgICBjdHguZm9udCA9ICIxNXB4IEFyaWFsIjsKICAgICAgY3R4LnRleHRBbGlnbiA9ICJjZW50ZXIiOwogICAgICBjdHgudGV4dEJhc2VsaW5lID0gIm1pZGRsZSI7CiAgICAgIGN0eC5maWxsU3R5bGUgPSAicmVkIjsKICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRXb3JkID09PSB3b3JkKSB7CiAgICAgICAgLy8ga2VlcCB0aGUgY2FudmFzIGNsZWFyIGNhbnZhcyBpZiB1c2VyIGNsaWNrZWQgdGhlIHdvcmQgYnV0dG9uIGEgc2Vjb25kIGNvbnNlY3V0aXZlIHRpbWUKICAgICAgICB0aGlzLnNlbGVjdGVkV29yZCA9ICIiOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICB0aGlzLnNlbGVjdGVkV29yZCA9IHdvcmQ7IC8vIGluaXRpYWxpemUgbGlzdHMgb2YgYm94ZXMgYW5kIG1hcmtlcnMgdG8gYmUgZHJhd24KICAgICAgdmFyIGJveE1hcCA9IG5ldyBNYXAoKTsKICAgICAgdmFyIG1hcmtlcnMgPSBbXTsKICAgICAgdmFyIGVzX2RhdGEgPSB0aGlzLmVsYXN0aWNzZWFyY2hfZGF0YTsKICAgICAgZXNfZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHsKICAgICAgICBpZiAocmVjb3JkLkRldGVjdGVkVGV4dCA9PT0gd29yZCkgewogICAgICAgICAgLy8gU2F2ZSB3b3JkIHRleHQgb3ZlcmxheWluZyBvbiB2aWRlbyB0aW1lbGluZQogICAgICAgICAgbWFya2Vycy5wdXNoKHsKICAgICAgICAgICAgJ3RpbWUnOiByZWNvcmQuVGltZXN0YW1wIC8gMTAwMCwKICAgICAgICAgICAgJ3RleHQnOiByZWNvcmQuRGV0ZWN0ZWRUZXh0LAogICAgICAgICAgICAnb3ZlcmxheVRleHQnOiByZWNvcmQuRGV0ZWN0ZWRUZXh0CiAgICAgICAgICB9KTsKICAgICAgICAgIC8vIFNhdmUgYm91bmRpbmcgYm94IGluZm8gaWYgaXQgZXhpc3RzCiAgICAgICAgICBpZiAocmVjb3JkLkJvdW5kaW5nQm94KSB7CiAgICAgICAgICAgIHZhciBpdGVtID0gcmVjb3JkOwogICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIGltYWdlIHByb2Nlc3NpbmcgdG8gYSBzZXBhcmF0ZSBjb21wb25lbnQKICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFUeXBlID09PSAiaW1hZ2UiKSB7CiAgICAgICAgICAgICAgLy8gdXNlIHRpbWVzdGFtcCB0byBpbmRleCBib3hlcyBpbiB0aGUgYm94TWFwIGNvbGxlY3Rpb24KICAgICAgICAgICAgICB2YXIgYm94aW5mbyA9IHsKICAgICAgICAgICAgICAgICduYW1lJzogaXRlbS5EZXRlY3RlZFRleHQsCiAgICAgICAgICAgICAgICAnY29uZmlkZW5jZSc6IChpdGVtLkNvbmZpZGVuY2UgKiAxKS50b0ZpeGVkKDIpLAogICAgICAgICAgICAgICAgJ3gnOiBpdGVtLkJvdW5kaW5nQm94LkxlZnQgKiBjYW52YXMud2lkdGgsCiAgICAgICAgICAgICAgICAneSc6IGl0ZW0uQm91bmRpbmdCb3guVG9wICogY2FudmFzLmhlaWdodCwKICAgICAgICAgICAgICAgICd3aWR0aCc6IGl0ZW0uQm91bmRpbmdCb3guV2lkdGggKiBjYW52YXMud2lkdGgsCiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaXRlbS5Cb3VuZGluZ0JveC5IZWlnaHQgKiBjYW52YXMuaGVpZ2h0CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBib3hNYXAuc2V0KGksIFtib3hpbmZvXSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgLy8gVXNlIHRpbWUgcmVzb2x1dGlvbiBvZiAwLjEgc2Vjb25kCiAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGgucm91bmQocmVjb3JkLlRpbWVzdGFtcCAvIDEwMCk7CiAgICAgICAgICAgICAgdmFyIF9ib3hpbmZvID0gewogICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IE1hdGguY2VpbChyZWNvcmQuVGltZXN0YW1wIC8gMTAwKSwKICAgICAgICAgICAgICAgICduYW1lJzogcmVjb3JkLkRldGVjdGVkVGV4dCwKICAgICAgICAgICAgICAgICdjb25maWRlbmNlJzogKHJlY29yZC5Db25maWRlbmNlICogMSkudG9GaXhlZCgyKSwKICAgICAgICAgICAgICAgICd4JzogaXRlbS5Cb3VuZGluZ0JveC5MZWZ0ICogY2FudmFzLndpZHRoLAogICAgICAgICAgICAgICAgJ3knOiBpdGVtLkJvdW5kaW5nQm94LlRvcCAqIGNhbnZhcy5oZWlnaHQsCiAgICAgICAgICAgICAgICAnd2lkdGgnOiBpdGVtLkJvdW5kaW5nQm94LldpZHRoICogY2FudmFzLndpZHRoLAogICAgICAgICAgICAgICAgJ2hlaWdodCc6IGl0ZW0uQm91bmRpbmdCb3guSGVpZ2h0ICogY2FudmFzLmhlaWdodAogICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGJvdW5kaW5nIGJveGVzIGZvciB0aGlzIGluc3RhbmNlIGF0IHRoaXMKICAgICAgICAgICAgICAvLyB0aW1lc3RhbXAsIHRoZW4gc2F2ZSB0aGVtIHRvZ2V0aGVyIGluIGFuIGFycmF5LgogICAgICAgICAgICAgIGlmIChib3hNYXAuaGFzKHRpbWVzdGFtcCkpIHsKICAgICAgICAgICAgICAgIGJveE1hcC5nZXQodGltZXN0YW1wKS5wdXNoKF9ib3hpbmZvKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgYm94TWFwLnNldCh0aW1lc3RhbXAsIFtfYm94aW5mb10pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfS5iaW5kKHRoaXMpKTsKICAgICAgaWYgKGJveE1hcC5zaXplID4gMCkgewogICAgICAgIHRoaXMuZHJhd0JveGVzKGJveE1hcCk7CiAgICAgIH0KICAgICAgLy8gVE9ETzogbW92ZSBpbWFnZSBwcm9jZXNzaW5nIHRvIGEgc2VwYXJhdGUgY29tcG9uZW50CiAgICAgIGlmICh0aGlzLm1lZGlhVHlwZSA9PT0gInZpZGVvIikgewogICAgICAgIC8vIHJlZHJhdyBtYXJrZXJzIG9uIHZpZGVvIHRpbWVsaW5lCiAgICAgICAgdGhpcy5wbGF5ZXIubWFya2Vycy5yZW1vdmVBbGwoKTsKICAgICAgICB0aGlzLnBsYXllci5tYXJrZXJzLmFkZChtYXJrZXJzKTsKICAgICAgfQogICAgfSwKICAgIGZldGNoQXNzZXREYXRhOiBmdW5jdGlvbiBmZXRjaEFzc2V0RGF0YSgpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUoKSB7CiAgICAgICAgdmFyIGFwaU5hbWUsIHBhdGgsIGFwaVBhcmFtcywgcmVzcG9uc2UsIGVzX2RhdGEsIHJlc3VsdCwgZGF0YSwgX2ksIGxlbjsKICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQpIHsKICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Lm4pIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIGFwaU5hbWUgPSAnY29udGVudEFuYWx5c2lzRWxhc3RpY3NlYXJjaCc7CiAgICAgICAgICAgICAgcGF0aCA9ICcvX3NlYXJjaCc7CiAgICAgICAgICAgICAgYXBpUGFyYW1zID0gewogICAgICAgICAgICAgICAgaGVhZGVyczogewogICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nCiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgcXVlcnlTdHJpbmdQYXJhbWV0ZXJzOiB7CiAgICAgICAgICAgICAgICAgICdxJzogX3RoaXMuc2VhcmNoUXVlcnksCiAgICAgICAgICAgICAgICAgICdkZWZhdWx0X29wZXJhdG9yJzogJ0FORCcsCiAgICAgICAgICAgICAgICAgICdzaXplJzogMTAwMDAKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAxOwogICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kQW1wbGlmeS5BUEkuZ2V0KGFwaU5hbWUsIHBhdGgsIGFwaVBhcmFtcyk7CiAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0LnY7CiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7CiAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBfdGhpcy5zaG93RWxhc3RpY1NlYXJjaEFsZXJ0ID0gdHJ1ZTsKICAgICAgICAgICAgICBfY29udGV4dC5uID0gNDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgIGVzX2RhdGEgPSBbXTsKICAgICAgICAgICAgICBfY29udGV4dC5uID0gMzsKICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7CiAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC52OwogICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQuaGl0cy5oaXRzOwogICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiBfdGhpcy5Db25maWRlbmNlID4gNTUpIHsKICAgICAgICAgICAgICAgIF90aGlzLmxvd2VyQ29uZmlkZW5jZSA9IHRydWU7CiAgICAgICAgICAgICAgICBfdGhpcy5sb3dlckNvbmZpZGVuY2VNZXNzYWdlID0gJ1RyeSBsb3dlcmluZyBjb25maWRlbmNlIHRocmVzaG9sZCc7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIF90aGlzLmxvd2VyQ29uZmlkZW5jZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgZm9yIChfaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBfaSA8IGxlbjsgX2krKykgewogICAgICAgICAgICAgICAgICBlc19kYXRhLnB1c2goZGF0YVtfaV0uX3NvdXJjZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIF90aGlzLmVsYXN0aWNzZWFyY2hfZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXNfZGF0YSkpOwogICAgICAgICAgICAgIF90aGlzLmlzQnVzeSA9IGZhbHNlOwogICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmEoMik7CiAgICAgICAgICB9CiAgICAgICAgfSwgX2NhbGxlZSk7CiAgICAgIH0pKSgpOwogICAgfSwKICAgIGRyYXdCb3hlczogZnVuY3Rpb24gZHJhd0JveGVzKGJveE1hcCkgewogICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpOwogICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICAgIC8vIFRPRE86IG1vdmUgaW1hZ2UgcHJvY2Vzc2luZyB0byBhIHNlcGFyYXRlIGNvbXBvbmVudAogICAgICBpZiAodGhpcy5tZWRpYVR5cGUgPT09ICJpbWFnZSIpIHsKICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgY3R4LmJlZ2luUGF0aCgpOwogICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICJyZWQiOwogICAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICAgIGN0eC50ZXh0QWxpZ24gPSAiY2VudGVyIjsKICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gIm1pZGRsZSI7CiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICAgIC8vIEZvciBlYWNoIGJveCBpbnN0YW5jZS4uLgogICAgICAgIGJveE1hcC5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7CiAgICAgICAgICB2YXIgZHJhd01lID0gaVswXTsKICAgICAgICAgIGlmIChkcmF3TWUpIHsKICAgICAgICAgICAgY3R4LnJlY3QoZHJhd01lLngsIGRyYXdNZS55LCBkcmF3TWUud2lkdGgsIGRyYXdNZS5oZWlnaHQpOwogICAgICAgICAgICAvLyBEcmF3IG9iamVjdCBuYW1lIGFuZCBjb25maWRlbmNlIHNjb3JlCiAgICAgICAgICAgIGN0eC5maWxsVGV4dChkcmF3TWUubmFtZSArICIgKCIgKyBkcmF3TWUuY29uZmlkZW5jZSArICIlKSIsIGRyYXdNZS54ICsgZHJhd01lLndpZHRoIC8gMiwgZHJhd01lLnkgLSAxMCk7CiAgICAgICAgICAgIGN0eC5zdHJva2UoKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICAvLyBub3cgcmV0dXJuIHNvIHdlIGF2b2lkIHJlbmRlcmluZyBhbnkgb2YgdGhlIHZpZGVvIHJlbGF0ZWQgY29tcG9uZW50cyBiZWxvdwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICAvLyBJZiB1c2VyIGp1c3QgY2xpY2tlZCBhIG5ldyB3b3JkLi4uCiAgICAgIGlmICh0aGlzLmNhbnZhc1JlZnJlc2hJbnRlcnZhbCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgLy8gLi4udGhlbiByZXNldCB0aGUgb2xkIGNhbnZhcyByZWZyZXNoIGludGVydmFsLgogICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwpOwogICAgICB9CiAgICAgIC8vIExvb2sgZm9yIGFuZCBkcmF3IGJvdW5kaW5nIGJveGVzIGV2ZXJ5IDEwMG1zCiAgICAgIHZhciBpbnRlcnZhbF9tcyA9IDEwMDsKICAgICAgdmFyIGVyYXNlX29uX2l0ZXJhdGlvbiA9IDI7CiAgICAgIHZhciBpID0gMDsKICAgICAgdGhpcy5jYW52YXNSZWZyZXNoSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7CiAgICAgICAgaSsrOwogICAgICAgIC8vIGVyYXNlIG9sZCBib3VuZGluZyBib3hlcwogICAgICAgIGlmICghdGhpcy5wbGF5ZXIucGF1c2VkKCkgJiYgaSAlIGVyYXNlX29uX2l0ZXJhdGlvbiA9PT0gMCkgewogICAgICAgICAgaSA9IDA7CiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAicmVkIjsKICAgICAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICJjZW50ZXIiOwogICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICJtaWRkbGUiOwogICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICAgIH0KICAgICAgICAvLyBHZXQgY3VycmVudCBwbGF5ZXIgdGltZXN0YW1wIHRvIHRoZSBuZWFyZXN0IDEvMTB0aCBzZWNvbmQKICAgICAgICB2YXIgcGxheWVyX3RpbWVzdGFtcCA9IE1hdGgucm91bmQodGhpcy5wbGF5ZXIuY3VycmVudFRpbWUoKSAqIDEwLjApOwogICAgICAgIC8vIElmIHdlIGhhdmUgYSBib3ggZm9yIHRoZSBwbGF5ZXIncyB0aW1lc3RhbXAuLi4KICAgICAgICBpZiAoYm94TWFwLmhhcyhwbGF5ZXJfdGltZXN0YW1wKSkgewogICAgICAgICAgaSA9IDA7CiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7CiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAicmVkIjsKICAgICAgICAgIGN0eC5mb250ID0gIjE1cHggQXJpYWwiOwogICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICJjZW50ZXIiOwogICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICJtaWRkbGUiOwogICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZWQiOwogICAgICAgICAgLy8gLi4udGhlbiBnZXQgYSBsaXN0IG9mIGJveCBpbnN0YW5jZXMKICAgICAgICAgIHZhciBpbnN0YW5jZV9saXN0ID0gYm94TWFwLmdldChwbGF5ZXJfdGltZXN0YW1wKS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5zdGFuY2U7CiAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHYsIGksIGEpIHsKICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXhPZih2KSA9PT0gaTsKICAgICAgICAgIH0pOwogICAgICAgICAgLy8gRm9yIGVhY2ggYm94IGluc3RhbmNlLi4uCiAgICAgICAgICBpbnN0YW5jZV9saXN0LmZvckVhY2goZnVuY3Rpb24gKGkpIHsKICAgICAgICAgICAgLy8gLi4uZ2V0IGFsbCBvZiB0aGUgYm94ZXMgYmVsb25naW5nIHRvIHRoaXMgaW5zdGFuY2UKICAgICAgICAgICAgLy8gYXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wLgogICAgICAgICAgICB2YXIgYm94ZXMgPSBib3hNYXAuZ2V0KHBsYXllcl90aW1lc3RhbXApLmZpbHRlcihmdW5jdGlvbiAoYm94KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGJveC5pbnN0YW5jZSA9PT0gaTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGJveGVzLmZvckVhY2goZnVuY3Rpb24gKGRyYXdNZSkgewogICAgICAgICAgICAgIGlmIChkcmF3TWUpIHsKICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRyYXdNZS54LCBkcmF3TWUueSwgZHJhd01lLndpZHRoLCBkcmF3TWUuaGVpZ2h0KTsKICAgICAgICAgICAgICAgIC8vIERyYXcgb2JqZWN0IG5hbWUgYW5kIGNvbmZpZGVuY2Ugc2NvcmUKICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChkcmF3TWUubmFtZSArICIgKCIgKyBkcmF3TWUuY29uZmlkZW5jZSArICIlKSIsIGRyYXdNZS54ICsgZHJhd01lLndpZHRoIC8gMiwgZHJhd01lLnkgLSAxMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgIH0pOwogICAgICAgICAgY3R4LnN0cm9rZSgpOwogICAgICAgIH0KICAgICAgfS5iaW5kKHRoaXMpLCBpbnRlcnZhbF9tcyk7CiAgICB9LAogICAgY2hhcnREYXRhOiBmdW5jdGlvbiBjaGFydERhdGEoKSB7CiAgICAgIHZhciB0aW1lc2VyaWVzID0gbmV3IE1hcCgpOwogICAgICBmdW5jdGlvbiBzYXZlVGltZXN0YW1wKG1pbGxpc2Vjb25kKSB7CiAgICAgICAgaWYgKHRpbWVzZXJpZXMuaGFzKG1pbGxpc2Vjb25kKSkgewogICAgICAgICAgdGltZXNlcmllcy5zZXQobWlsbGlzZWNvbmQsIHsKICAgICAgICAgICAgIngiOiBtaWxsaXNlY29uZCwKICAgICAgICAgICAgInkiOiB0aW1lc2VyaWVzLmdldChtaWxsaXNlY29uZCkueSArIDEKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aW1lc2VyaWVzLnNldChtaWxsaXNlY29uZCwgewogICAgICAgICAgICAieCI6IG1pbGxpc2Vjb25kLAogICAgICAgICAgICAieSI6IDEKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgZXNfZGF0YSA9IHRoaXMuZWxhc3RpY3NlYXJjaF9kYXRhOwogICAgICBlc19kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkgewogICAgICAgIC8vIERlZmluZSB0aW1lc3RhbXAgd2l0aCBtaWxsaXNlY29uZCByZXNvbHV0aW9uCiAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChyZWNvcmQuVGltZXN0YW1wKTsKICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFdvcmQpIHsKICAgICAgICAgIC8vIElmIHdvcmQgaXMgZGVmaW5lZCwgdGhlbiBlbnVtZXJhdGUgdGltZXN0YW1wcyBmb3IgdGhhdCB3b3JkCiAgICAgICAgICBpZiAocmVjb3JkLkRldGVjdGVkVGV4dCA9PT0gdGhpcy5zZWxlY3RlZFdvcmQpIHsKICAgICAgICAgICAgc2F2ZVRpbWVzdGFtcChtaWxsaXNlY29uZCk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIE5vIHdvcmQgaGFzIGJlZW4gc2VsZWN0ZWQsIHNvIGVudW1lcmF0ZSB0aW1lc3RhbXBzIGZvciBhbGwgd29yZCBuYW1lcy4KICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBib3VuZGluZyBib3hlcyBpZiBwcmVzZW50LgogICAgICAgICAgc2F2ZVRpbWVzdGFtcChtaWxsaXNlY29uZCk7CiAgICAgICAgfQogICAgICB9LmJpbmQodGhpcykpOwogICAgICAvL3NvcnQgdGhlIHRpbWVzZXJpZXMgbWFwIGJ5IGl0cyBtaWxsaXNlY29uZCBrZXkKICAgICAgdmFyIG9yZGVyZWRfdGltZXNlcmllcyA9IG5ldyBNYXAoX3RvQ29uc3VtYWJsZUFycmF5KHRpbWVzZXJpZXMuZW50cmllcygpKS5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07CiAgICAgIH0pKTsKICAgICAgdmFyIGNoYXJ0VHVwbGVzID0gQXJyYXkuZnJvbShvcmRlcmVkX3RpbWVzZXJpZXMudmFsdWVzKCkpOwogICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3VwZGF0ZVRpbWVzZXJpZXMnLCBjaGFydFR1cGxlcyk7CiAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgndXBkYXRlU2VsZWN0ZWRMYWJlbCcsIHRoaXMuc2VsZWN0ZWRXb3JkKTsKICAgIH0KICB9Cn07"},{"version":3,"names":["Loading","mapState","name","components","props","mediaType","type","String","default","data","curlCommand","searchQuery","showElasticsearchApiRequest","Confidence","high_confidence_data","elasticsearch_data","boxes_available","count_distinct_words","count_words","isBusy","operator","canvasRefreshInterval","undefined","timeseries","Map","selectedWord","lowerConfidence","lowerConfidenceMessage","computed","_objectSpread","sorted_unique_word_detections","es_data","console","log","unique_words","forEach","record","Type","set","DetectedText","get","BoundingBox","saveBoxedDetectedText","bind","sorted_unique_words","_toConsumableArray","entries","slice","sort","a","b","delete","countDetectedWords","size","length","watch","chartData","deactivated","clearInterval","canvas","document","getElementById","ctx","getContext","clearRect","width","height","activated","fetchAssetData","mounted","getCurlCommand","beforeDestroy","methods","$route","params","asset_id","AWS_REGION","SEARCH_ENDPOINT","encodeURIComponent","detectedText","includes","push","uniqueWordCount","totalWordCount","saveFile","JSON","stringify","blob","Blob","e","createEvent","createElement","download","href","window","URL","createObjectURL","dataset","downloadurl","join","initEvent","dispatchEvent","updateConfidence","event","target","value","player","markers","removeAll","updateMarkers","word","strokeStyle","font","textAlign","textBaseline","fillStyle","boxMap","Timestamp","item","boxinfo","toFixed","Left","Top","Width","Height","i","timestamp","Math","round","ceil","has","drawBoxes","add","_this","_asyncToGenerator","_regenerator","m","_callee","apiName","path","apiParams","response","result","_i","len","w","_context","n","headers","queryStringParameters","$Amplify","API","v","showElasticSearchAlert","hits","_source","parse","beginPath","drawMe","rect","x","y","fillText","confidence","stroke","interval_ms","erase_on_iteration","setInterval","paused","player_timestamp","currentTime","instance_list","map","instance","filter","indexOf","boxes","box","saveTimestamp","millisecond","ordered_timeseries","chartTuples","Array","from","values","$store","commit"],"sources":["src/components/TextDetection.vue"],"sourcesContent":["<template>\n  <b-container fluid>\n    <b-col>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          Confidence Threshold<br>\n          <input\n            type=\"range\"\n            value=\"90\"\n            min=\"55\"\n            max=\"99\"\n            step=\"1\"\n            @click=\"updateConfidence\"\n          >\n          {{ Confidence }}%<br>\n        </div>\n      </b-row>\n      <div v-if=\"lowerConfidence === true\">\n        {{ lowerConfidenceMessage }}\n      </div>\n      <div\n        v-if=\"isBusy\"\n        class=\"wrapper\"\n      >\n        <Loading />\n      </div>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div class=\"wrapper\">\n          <br>\n          <template v-for=\"detectedWords in sorted_unique_word_detections\">\n            <template v-if=\"boxes_available.includes(detectedWords[0])\">\n              <!-- Show darker button outline if bounding boxes are available for the detected text -->\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-dark\"\n                :title=\"detectedWords[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(detectedWords[0])\"\n              >\n                {{ detectedWords[0]+\"*\" }}\n              </b-button> &nbsp;\n            </template>\n            <template v-else>\n              <b-button\n                v-b-tooltip.hover\n                variant=\"outline-secondary\"\n                :title=\"detectedWords[1]\"\n                size=\"sm\"\n                pill\n                @click=\"updateMarkers(detectedWords[0])\"\n              >\n                {{ detectedWords[0] }}\n              </b-button> &nbsp;\n            </template>\n          </template>\n        </div>\n      </b-row>\n      <b-row\n        align-h=\"center\"\n        class=\"my-1\"\n      >\n        <div\n          v-if=\"isBusy === false\"\n          class=\"wrapper\"\n        >\n          <p class=\"text-muted\">\n            ({{ count_words }} identified text objects, {{ count_distinct_words }} unique)\n          </p>\n          <hr>\n          <p class=\"text-muted\">\n            * Indicates bounding boxes are available.\n          </p>\n        </div>\n      </b-row>\n    </b-col>\n    <b-button\n      type=\"button\"\n      @click=\"saveFile()\"\n    >\n      Download Data\n    </b-button>\n    <br>\n    <b-button\n        :pressed=\"false\"\n        size=\"sm\"\n        variant=\"link\"\n        class=\"text-decoration-none\"\n        @click=\"showElasticsearchApiRequest = true\"\n    >\n      Show API request to get these results\n    </b-button>\n    <b-modal\n        v-model=\"showElasticsearchApiRequest\"\n        scrollable\n        title=\"SEARCH API\"\n        ok-only\n    >\n      <label>Request URL:</label>\n      <pre v-highlightjs><code class=\"bash\">GET {{ SEARCH_ENDPOINT }}workflow/execution</code></pre>\n      <label>Search query:</label>\n      <pre v-highlightjs=\"JSON.stringify(searchQuery)\"><code class=\"json\"></code></pre>\n      <label>Sample command:</label>\n      <pre v-highlightjs=\"curlCommand\"><code class=\"bash\"></code></pre>\n    </b-modal>\n  </b-container>\n</template>\n\n<script>\n  import Loading from '@/components/Loading.vue'\n  import { mapState } from 'vuex'\n  // TODO: Think about how to handle \"LINE\" detection types, maybe another component? or a drop down to filter words / lines\n  export default {\n    name: \"TextDetection\",\n    components: {\n      Loading\n    },\n    props: {\n      mediaType: {\n        type: String,\n        default: \"\"\n      },\n    },\n    data() {\n      return {\n        curlCommand: '',\n        searchQuery: '',\n        showElasticsearchApiRequest: false,\n        Confidence: 90,\n        high_confidence_data: [],\n        elasticsearch_data: [],\n        boxes_available: [],\n        count_distinct_words: 0,\n        count_words: 0,\n        //count_distinct_lines: 0,\n        //count_lines: 0,\n        isBusy: false,\n        operator: 'textDetection',\n        canvasRefreshInterval: undefined,\n        timeseries: new Map(),\n        selectedWord: '',\n        lowerConfidence: false,\n        lowerConfidenceMessage: 'Try lowering confidence threshold',\n      }\n    },\n    computed: {\n      ...mapState(['player']),\n      sorted_unique_word_detections() {\n        // This function sorts and counts unique words for mouse over events on buttons\n        const es_data = this.elasticsearch_data;\n        console.log(es_data)\n        const unique_words = new Map();\n        //const unique_lines = new Map();\n        // sort and count unique words for mouse over events\n        es_data.forEach(function (record) {\n          if (record.Type == 'WORD') {\n            unique_words.set(record.DetectedText, unique_words.get(record.DetectedText) ? unique_words.get(record.DetectedText) + 1 : 1);\n          }\n          // if (record.TextType == 'LINE') {\n          //   unique_lines.set(record.DetectedText, unique_lines.get(record.DetectedText) ? unique_lines.get(record.DetectedText) + 1 : 1);\n          // }\n          if (record.BoundingBox) {\n            // Save this word detection to a list of words that have bounding boxes\n            this.saveBoxedDetectedText(record.DetectedText)\n          }\n        }.bind(this));\n        const sorted_unique_words = new Map([...unique_words.entries()].slice().sort((a, b) => b[1] - a[1]));\n        //const sorted_unique_lines = new Map([...unique_lines.entries()].slice().sort((a, b) => b[1] - a[1]));\n        // If Elasticsearch returned undefined words then delete them:\n        sorted_unique_words.delete(undefined);\n        //sorted_unique_lines.delete(undefined);\n        this.countDetectedWords(sorted_unique_words.size, es_data.length);\n        //this.countDetectedLines(sorted_unique_lines.size, es_data.length);\n        console.log(sorted_unique_words)\n        return sorted_unique_words\n      },\n    },\n    watch: {\n      // These watches update the line chart\n      selectedWord: function() {\n        this.chartData();\n      },\n      elasticsearch_data: function() {\n        this.chartData();\n      },\n    },\n    deactivated: function () {\n      this.boxes_available = [];\n      this.selectedWord = '';\n      clearInterval(this.canvasRefreshInterval);\n      const canvas = document.getElementById('canvas');\n      let ctx;\n      if (canvas) ctx = canvas.getContext('2d');\n      if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);\n    },\n    activated: function () {\n      this.fetchAssetData();\n    },\n    mounted: function() {\n      this.getCurlCommand();\n    },\n    beforeDestroy: function () {\n      this.high_confidence_data = [];\n      this.elasticsearch_data = [];\n      this.count_distinct_words = 0;\n      this.count_words = 0;\n      clearInterval(this.canvasRefreshInterval);\n    },\n    methods: {\n      getCurlCommand() {\n        this.searchQuery = 'AssetId:'+this.$route.params.asset_id+' Confidence:>'+this.Confidence+' Operator:'+this.operator;\n        // get curl command to search elasticsearch\n        this.curlCommand = 'awscurl -X GET --profile default --service es --region ' + this.AWS_REGION + ' \\'' + this.SEARCH_ENDPOINT + '/_search?q=' + encodeURIComponent(this.searchQuery) + '\\''\n      },\n      saveBoxedDetectedText(detectedText){\n        if (!this.boxes_available.includes(detectedText)) {\n          this.boxes_available.push(detectedText);\n        }\n      },\n      countDetectedWords(uniqueWordCount, totalWordCount) {\n        this.count_distinct_words = uniqueWordCount;\n        this.count_words = totalWordCount;\n        // this.count_distinct_lines = uniqueLineCount;\n        // this.count_lines = totalLineCount;\n      },\n      saveFile() {\n        const elasticsearch_data = JSON.stringify(this.elasticsearch_data);\n        const blob = new Blob([elasticsearch_data], {type: 'text/plain'});\n        const e = document.createEvent('MouseEvents'),\n          a = document.createElement('a');\n        a.download = \"data.json\";\n        a.href = window.URL.createObjectURL(blob);\n        a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');\n        e.initEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n        a.dispatchEvent(e);\n      },\n      updateConfidence (event) {\n        this.isBusy = true;\n        this.Confidence = event.target.value;\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n        }\n        this.getCurlCommand();\n        this.fetchAssetData();\n      },\n      // updateMarkers updates markers in the video player and is called when someone clicks on a word button\n      updateMarkers (word) {\n        // clear canvas for redrawing\n        this.boxes_available = [];\n        clearInterval(this.canvasRefreshInterval);\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.strokeStyle = \"red\";\n        ctx.font = \"15px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillStyle = \"red\";\n        if (this.selectedWord === word) {\n          // keep the canvas clear canvas if user clicked the word button a second consecutive time\n          this.selectedWord = \"\";\n          return\n        }\n        this.selectedWord = word;        // initialize lists of boxes and markers to be drawn\n        const boxMap = new Map();\n        const markers = [];\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          if (record.DetectedText === word) {\n            // Save word text overlaying on video timeline\n            markers.push({'time': record.Timestamp/1000, 'text': record.DetectedText, 'overlayText': record.DetectedText});\n            // Save bounding box info if it exists\n            if (record.BoundingBox) {\n                const item = record;\n                // TODO: move image processing to a separate component\n                if (this.mediaType === \"image\") {\n                  // use timestamp to index boxes in the boxMap collection\n                  const boxinfo = {\n                    'name': item.DetectedText,\n                    'confidence': (item.Confidence * 1).toFixed(2),\n                    'x': item.BoundingBox.Left * canvas.width,\n                    'y': item.BoundingBox.Top * canvas.height,\n                    'width': item.BoundingBox.Width * canvas.width,\n                    'height': item.BoundingBox.Height * canvas.height\n                  };\n                  boxMap.set(i, [boxinfo])\n                } else {\n                  // Use time resolution of 0.1 second\n                  const timestamp = Math.round(record.Timestamp/100);\n                  const boxinfo = {'timestamp':Math.ceil(record.Timestamp/100), 'name':record.DetectedText, 'confidence':(record.Confidence * 1).toFixed(2), 'x':item.BoundingBox.Left*canvas.width, 'y':item.BoundingBox.Top*canvas.height, 'width':item.BoundingBox.Width*canvas.width, 'height':item.BoundingBox.Height*canvas.height};\n                  // If there are multiple bounding boxes for this instance at this\n                  // timestamp, then save them together in an array.\n                  if (boxMap.has(timestamp)) {\n                    boxMap.get(timestamp).push(boxinfo)\n                  } else {\n                    boxMap.set(timestamp, [boxinfo])\n                  }\n                }\n            }\n          }\n        }.bind(this));\n        if (boxMap.size > 0) {\n          this.drawBoxes(boxMap);\n        }\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"video\") {\n          // redraw markers on video timeline\n          this.player.markers.removeAll();\n          this.player.markers.add(markers);\n        }\n      },\n      async fetchAssetData () {\n          let apiName = 'contentAnalysisElasticsearch';\n          let path = '/_search';\n          let apiParams = {\n            headers: {'Content-Type': 'application/json'},\n            queryStringParameters: {'q': this.searchQuery, 'default_operator': 'AND', 'size': 10000}\n          };\n          let response = await this.$Amplify.API.get(apiName, path, apiParams);\n          if (!response) {\n            this.showElasticSearchAlert = true\n          }\n          else {\n            let es_data = [];\n            let result = await response;\n            let data = result.hits.hits;\n            if (data.length === 0 && this.Confidence > 55) {\n                this.lowerConfidence = true;\n                this.lowerConfidenceMessage = 'Try lowering confidence threshold'\n            }\n            else {\n              this.lowerConfidence = false;\n              for (let i = 0, len = data.length; i < len; i++) {\n                es_data.push(data[i]._source)\n              }\n            }\n            this.elasticsearch_data = JSON.parse(JSON.stringify(es_data));\n            this.isBusy = false\n        }\n      },\n      drawBoxes: function(boxMap) {\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        // TODO: move image processing to a separate component\n        if (this.mediaType === \"image\") {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.strokeStyle = \"red\";\n          ctx.font = \"15px Arial\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillStyle = \"red\";\n          // For each box instance...\n          boxMap.forEach( i => {\n            const drawMe = i[0];\n            if (drawMe) {\n              ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n              // Draw object name and confidence score\n              ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n              ctx.stroke();\n            }\n          });\n          // now return so we avoid rendering any of the video related components below\n          return\n        }\n        // If user just clicked a new word...\n        if (this.canvasRefreshInterval !== undefined) {\n          // ...then reset the old canvas refresh interval.\n          clearInterval(this.canvasRefreshInterval)\n        }\n        // Look for and draw bounding boxes every 100ms\n        const interval_ms = 100;\n        const erase_on_iteration = 2;\n        let i = 0;\n        this.canvasRefreshInterval = setInterval(function () {\n          i++;\n          // erase old bounding boxes\n          if (!this.player.paused() && i % erase_on_iteration === 0) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n          }\n          // Get current player timestamp to the nearest 1/10th second\n          const player_timestamp = Math.round(this.player.currentTime()*10.0);\n          // If we have a box for the player's timestamp...\n          if (boxMap.has(player_timestamp)) {\n            i=0;\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.beginPath();\n            ctx.strokeStyle = \"red\";\n            ctx.font = \"15px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.textBaseline = \"middle\";\n            ctx.fillStyle = \"red\";\n            // ...then get a list of box instances\n            const instance_list = (boxMap.get(player_timestamp)).map( item => item.instance).filter((v, i, a) => a.indexOf(v) === i);\n            // For each box instance...\n            instance_list.forEach( i => {\n              // ...get all of the boxes belonging to this instance\n              // at the current timestamp.\n              const boxes = boxMap.get(player_timestamp).filter(box => box.instance === i);\n              boxes.forEach (drawMe => {\n                if (drawMe) {\n                  ctx.rect(drawMe.x, drawMe.y, drawMe.width, drawMe.height);\n                  // Draw object name and confidence score\n                  ctx.fillText(drawMe.name + \" (\" + drawMe.confidence + \"%)\", (drawMe.x + drawMe.width / 2), drawMe.y - 10);\n                }\n              })\n            });\n            ctx.stroke();\n          }\n        }.bind(this), interval_ms);\n      },\n      chartData() {\n        let timeseries = new Map();\n        function saveTimestamp (millisecond) {\n          if (timeseries.has(millisecond)) {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\": timeseries.get(millisecond).y + 1})\n          } else {\n            timeseries.set(millisecond, {\"x\": millisecond, \"y\":1})\n          }\n        }\n        const es_data = this.elasticsearch_data;\n        es_data.forEach( function(record) {\n          // Define timestamp with millisecond resolution\n          const millisecond = Math.round(record.Timestamp);\n          if (this.selectedWord) {\n            // If word is defined, then enumerate timestamps for that word\n            if (record.DetectedText === this.selectedWord) {\n                  saveTimestamp(millisecond);\n            }\n          }\n          else {\n            // No word has been selected, so enumerate timestamps for all word names.\n            // Iterate through bounding boxes if present.\n            saveTimestamp(millisecond);\n          }\n        }.bind(this));\n        //sort the timeseries map by its millisecond key\n        const ordered_timeseries = new Map([...timeseries.entries()].slice().sort((a, b) => a[0] - b[0]));\n        const chartTuples = Array.from(ordered_timeseries.values());\n        this.$store.commit('updateTimeseries', chartTuples);\n        this.$store.commit('updateSelectedLabel', this.selectedWord);\n      },\n    }\n  }\n</script>\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmHA,OAAAA,OAAA;AACA,SAAAC,QAAA;AACA;AACA;EACAC,IAAA;EACAC,UAAA;IACAH,OAAA,EAAAA;EACA;EACAI,KAAA;IACAC,SAAA;MACAC,IAAA,EAAAC,MAAA;MACAC,OAAA;IACA;EACA;EACAC,IAAA,WAAAA,KAAA;IACA;MACAC,WAAA;MACAC,WAAA;MACAC,2BAAA;MACAC,UAAA;MACAC,oBAAA;MACAC,kBAAA;MACAC,eAAA;MACAC,oBAAA;MACAC,WAAA;MACA;MACA;MACAC,MAAA;MACAC,QAAA;MACAC,qBAAA,EAAAC,SAAA;MACAC,UAAA,MAAAC,GAAA;MACAC,YAAA;MACAC,eAAA;MACAC,sBAAA;IACA;EACA;EACAC,QAAA,EAAAC,aAAA,CAAAA,aAAA,KACA5B,QAAA;IACA6B,6BAAA,WAAAA,8BAAA;MACA;MACA,IAAAC,OAAA,QAAAhB,kBAAA;MACAiB,OAAA,CAAAC,GAAA,CAAAF,OAAA;MACA,IAAAG,YAAA,OAAAV,GAAA;MACA;MACA;MACAO,OAAA,CAAAI,OAAA,WAAAC,MAAA;QACA,IAAAA,MAAA,CAAAC,IAAA;UACAH,YAAA,CAAAI,GAAA,CAAAF,MAAA,CAAAG,YAAA,EAAAL,YAAA,CAAAM,GAAA,CAAAJ,MAAA,CAAAG,YAAA,IAAAL,YAAA,CAAAM,GAAA,CAAAJ,MAAA,CAAAG,YAAA;QACA;QACA;QACA;QACA;QACA,IAAAH,MAAA,CAAAK,WAAA;UACA;UACA,KAAAC,qBAAA,CAAAN,MAAA,CAAAG,YAAA;QACA;MACA,EAAAI,IAAA;MACA,IAAAC,mBAAA,OAAApB,GAAA,CAAAqB,kBAAA,CAAAX,YAAA,CAAAY,OAAA,IAAAC,KAAA,GAAAC,IAAA,WAAAC,CAAA,EAAAC,CAAA;QAAA,OAAAA,CAAA,MAAAD,CAAA;MAAA;MACA;MACA;MACAL,mBAAA,CAAAO,MAAA,CAAA7B,SAAA;MACA;MACA,KAAA8B,kBAAA,CAAAR,mBAAA,CAAAS,IAAA,EAAAtB,OAAA,CAAAuB,MAAA;MACA;MACAtB,OAAA,CAAAC,GAAA,CAAAW,mBAAA;MACA,OAAAA,mBAAA;IACA;EAAA,EACA;EACAW,KAAA;IACA;IACA9B,YAAA,WAAAA,aAAA;MACA,KAAA+B,SAAA;IACA;IACAzC,kBAAA,WAAAA,mBAAA;MACA,KAAAyC,SAAA;IACA;EACA;EACAC,WAAA,WAAAA,YAAA;IACA,KAAAzC,eAAA;IACA,KAAAS,YAAA;IACAiC,aAAA,MAAArC,qBAAA;IACA,IAAAsC,MAAA,GAAAC,QAAA,CAAAC,cAAA;IACA,IAAAC,GAAA;IACA,IAAAH,MAAA,EAAAG,GAAA,GAAAH,MAAA,CAAAI,UAAA;IACA,IAAAD,GAAA,EAAAA,GAAA,CAAAE,SAAA,OAAAL,MAAA,CAAAM,KAAA,EAAAN,MAAA,CAAAO,MAAA;EACA;EACAC,SAAA,WAAAA,UAAA;IACA,KAAAC,cAAA;EACA;EACAC,OAAA,WAAAA,QAAA;IACA,KAAAC,cAAA;EACA;EACAC,aAAA,WAAAA,cAAA;IACA,KAAAzD,oBAAA;IACA,KAAAC,kBAAA;IACA,KAAAE,oBAAA;IACA,KAAAC,WAAA;IACAwC,aAAA,MAAArC,qBAAA;EACA;EACAmD,OAAA;IACAF,cAAA,WAAAA,eAAA;MACA,KAAA3D,WAAA,qBAAA8D,MAAA,CAAAC,MAAA,CAAAC,QAAA,0BAAA9D,UAAA,uBAAAO,QAAA;MACA;MACA,KAAAV,WAAA,oEAAAkE,UAAA,gBAAAC,eAAA,mBAAAC,kBAAA,MAAAnE,WAAA;IACA;IACA+B,qBAAA,WAAAA,sBAAAqC,YAAA;MACA,UAAA/D,eAAA,CAAAgE,QAAA,CAAAD,YAAA;QACA,KAAA/D,eAAA,CAAAiE,IAAA,CAAAF,YAAA;MACA;IACA;IACA3B,kBAAA,WAAAA,mBAAA8B,eAAA,EAAAC,cAAA;MACA,KAAAlE,oBAAA,GAAAiE,eAAA;MACA,KAAAhE,WAAA,GAAAiE,cAAA;MACA;MACA;IACA;IACAC,QAAA,WAAAA,SAAA;MACA,IAAArE,kBAAA,GAAAsE,IAAA,CAAAC,SAAA,MAAAvE,kBAAA;MACA,IAAAwE,IAAA,OAAAC,IAAA,EAAAzE,kBAAA;QAAAT,IAAA;MAAA;MACA,IAAAmF,CAAA,GAAA7B,QAAA,CAAA8B,WAAA;QACAzC,CAAA,GAAAW,QAAA,CAAA+B,aAAA;MACA1C,CAAA,CAAA2C,QAAA;MACA3C,CAAA,CAAA4C,IAAA,GAAAC,MAAA,CAAAC,GAAA,CAAAC,eAAA,CAAAT,IAAA;MACAtC,CAAA,CAAAgD,OAAA,CAAAC,WAAA,iBAAAjD,CAAA,CAAA2C,QAAA,EAAA3C,CAAA,CAAA4C,IAAA,EAAAM,IAAA;MACAV,CAAA,CAAAW,SAAA,uBAAAN,MAAA;MACA7C,CAAA,CAAAoD,aAAA,CAAAZ,CAAA;IACA;IACAa,gBAAA,WAAAA,iBAAAC,KAAA;MACA,KAAApF,MAAA;MACA,KAAAN,UAAA,GAAA0F,KAAA,CAAAC,MAAA,CAAAC,KAAA;MACA,SAAApG,SAAA;QACA;QACA,KAAAqG,MAAA,CAAAC,OAAA,CAAAC,SAAA;MACA;MACA,KAAAtC,cAAA;MACA,KAAAF,cAAA;IACA;IACA;IACAyC,aAAA,WAAAA,cAAAC,IAAA;MACA;MACA,KAAA9F,eAAA;MACA0C,aAAA,MAAArC,qBAAA;MACA,IAAAsC,MAAA,GAAAC,QAAA,CAAAC,cAAA;MACA,IAAAC,GAAA,GAAAH,MAAA,CAAAI,UAAA;MACAD,GAAA,CAAAE,SAAA,OAAAL,MAAA,CAAAM,KAAA,EAAAN,MAAA,CAAAO,MAAA;MACAJ,GAAA,CAAAiD,WAAA;MACAjD,GAAA,CAAAkD,IAAA;MACAlD,GAAA,CAAAmD,SAAA;MACAnD,GAAA,CAAAoD,YAAA;MACApD,GAAA,CAAAqD,SAAA;MACA,SAAA1F,YAAA,KAAAqF,IAAA;QACA;QACA,KAAArF,YAAA;QACA;MACA;MACA,KAAAA,YAAA,GAAAqF,IAAA;MACA,IAAAM,MAAA,OAAA5F,GAAA;MACA,IAAAmF,OAAA;MACA,IAAA5E,OAAA,QAAAhB,kBAAA;MACAgB,OAAA,CAAAI,OAAA,WAAAC,MAAA;QACA,IAAAA,MAAA,CAAAG,YAAA,KAAAuE,IAAA;UACA;UACAH,OAAA,CAAA1B,IAAA;YAAA,QAAA7C,MAAA,CAAAiF,SAAA;YAAA,QAAAjF,MAAA,CAAAG,YAAA;YAAA,eAAAH,MAAA,CAAAG;UAAA;UACA;UACA,IAAAH,MAAA,CAAAK,WAAA;YACA,IAAA6E,IAAA,GAAAlF,MAAA;YACA;YACA,SAAA/B,SAAA;cACA;cACA,IAAAkH,OAAA;gBACA,QAAAD,IAAA,CAAA/E,YAAA;gBACA,eAAA+E,IAAA,CAAAzG,UAAA,MAAA2G,OAAA;gBACA,KAAAF,IAAA,CAAA7E,WAAA,CAAAgF,IAAA,GAAA9D,MAAA,CAAAM,KAAA;gBACA,KAAAqD,IAAA,CAAA7E,WAAA,CAAAiF,GAAA,GAAA/D,MAAA,CAAAO,MAAA;gBACA,SAAAoD,IAAA,CAAA7E,WAAA,CAAAkF,KAAA,GAAAhE,MAAA,CAAAM,KAAA;gBACA,UAAAqD,IAAA,CAAA7E,WAAA,CAAAmF,MAAA,GAAAjE,MAAA,CAAAO;cACA;cACAkD,MAAA,CAAA9E,GAAA,CAAAuF,CAAA,GAAAN,OAAA;YACA;cACA;cACA,IAAAO,SAAA,GAAAC,IAAA,CAAAC,KAAA,CAAA5F,MAAA,CAAAiF,SAAA;cACA,IAAAE,QAAA;gBAAA,aAAAQ,IAAA,CAAAE,IAAA,CAAA7F,MAAA,CAAAiF,SAAA;gBAAA,QAAAjF,MAAA,CAAAG,YAAA;gBAAA,eAAAH,MAAA,CAAAvB,UAAA,MAAA2G,OAAA;gBAAA,KAAAF,IAAA,CAAA7E,WAAA,CAAAgF,IAAA,GAAA9D,MAAA,CAAAM,KAAA;gBAAA,KAAAqD,IAAA,CAAA7E,WAAA,CAAAiF,GAAA,GAAA/D,MAAA,CAAAO,MAAA;gBAAA,SAAAoD,IAAA,CAAA7E,WAAA,CAAAkF,KAAA,GAAAhE,MAAA,CAAAM,KAAA;gBAAA,UAAAqD,IAAA,CAAA7E,WAAA,CAAAmF,MAAA,GAAAjE,MAAA,CAAAO;cAAA;cACA;cACA;cACA,IAAAkD,MAAA,CAAAc,GAAA,CAAAJ,SAAA;gBACAV,MAAA,CAAA5E,GAAA,CAAAsF,SAAA,EAAA7C,IAAA,CAAAsC,QAAA;cACA;gBACAH,MAAA,CAAA9E,GAAA,CAAAwF,SAAA,GAAAP,QAAA;cACA;YACA;UACA;QACA;MACA,EAAA5E,IAAA;MACA,IAAAyE,MAAA,CAAA/D,IAAA;QACA,KAAA8E,SAAA,CAAAf,MAAA;MACA;MACA;MACA,SAAA/G,SAAA;QACA;QACA,KAAAqG,MAAA,CAAAC,OAAA,CAAAC,SAAA;QACA,KAAAF,MAAA,CAAAC,OAAA,CAAAyB,GAAA,CAAAzB,OAAA;MACA;IACA;IACAvC,cAAA,WAAAA,eAAA;MAAA,IAAAiE,KAAA;MAAA,OAAAC,iBAAA,cAAAC,YAAA,GAAAC,CAAA,UAAAC,QAAA;QAAA,IAAAC,OAAA,EAAAC,IAAA,EAAAC,SAAA,EAAAC,QAAA,EAAA9G,OAAA,EAAA+G,MAAA,EAAArI,IAAA,EAAAsI,EAAA,EAAAC,GAAA;QAAA,OAAAT,YAAA,GAAAU,CAAA,WAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,CAAA;YAAA;cACAT,OAAA;cACAC,IAAA;cACAC,SAAA;gBACAQ,OAAA;kBAAA;gBAAA;gBACAC,qBAAA;kBAAA,KAAAhB,KAAA,CAAA1H,WAAA;kBAAA;kBAAA;gBAAA;cACA;cAAAuI,QAAA,CAAAC,CAAA;cAAA,OACAd,KAAA,CAAAiB,QAAA,CAAAC,GAAA,CAAA/G,GAAA,CAAAkG,OAAA,EAAAC,IAAA,EAAAC,SAAA;YAAA;cAAAC,QAAA,GAAAK,QAAA,CAAAM,CAAA;cAAA,IACAX,QAAA;gBAAAK,QAAA,CAAAC,CAAA;gBAAA;cAAA;cACAd,KAAA,CAAAoB,sBAAA;cAAAP,QAAA,CAAAC,CAAA;cAAA;YAAA;cAGApH,OAAA;cAAAmH,QAAA,CAAAC,CAAA;cAAA,OACAN,QAAA;YAAA;cAAAC,MAAA,GAAAI,QAAA,CAAAM,CAAA;cACA/I,IAAA,GAAAqI,MAAA,CAAAY,IAAA,CAAAA,IAAA;cACA,IAAAjJ,IAAA,CAAA6C,MAAA,UAAA+E,KAAA,CAAAxH,UAAA;gBACAwH,KAAA,CAAA3G,eAAA;gBACA2G,KAAA,CAAA1G,sBAAA;cACA,OACA;gBACA0G,KAAA,CAAA3G,eAAA;gBACA,KAAAmG,EAAA,MAAAmB,GAAA,GAAAvI,IAAA,CAAA6C,MAAA,EAAAuE,EAAA,GAAAmB,GAAA,EAAAnB,EAAA;kBACA9F,OAAA,CAAAkD,IAAA,CAAAxE,IAAA,CAAAoH,EAAA,EAAA8B,OAAA;gBACA;cACA;cACAtB,KAAA,CAAAtH,kBAAA,GAAAsE,IAAA,CAAAuE,KAAA,CAAAvE,IAAA,CAAAC,SAAA,CAAAvD,OAAA;cACAsG,KAAA,CAAAlH,MAAA;YAAA;cAAA,OAAA+H,QAAA,CAAAjG,CAAA;UAAA;QAAA,GAAAwF,OAAA;MAAA;IAEA;IACAN,SAAA,WAAAA,UAAAf,MAAA;MACA,IAAAzD,MAAA,GAAAC,QAAA,CAAAC,cAAA;MACA,IAAAC,GAAA,GAAAH,MAAA,CAAAI,UAAA;MACA;MACA,SAAA1D,SAAA;QACAyD,GAAA,CAAAE,SAAA,OAAAL,MAAA,CAAAM,KAAA,EAAAN,MAAA,CAAAO,MAAA;QACAJ,GAAA,CAAA+F,SAAA;QACA/F,GAAA,CAAAiD,WAAA;QACAjD,GAAA,CAAAkD,IAAA;QACAlD,GAAA,CAAAmD,SAAA;QACAnD,GAAA,CAAAoD,YAAA;QACApD,GAAA,CAAAqD,SAAA;QACA;QACAC,MAAA,CAAAjF,OAAA,WAAA0F,CAAA;UACA,IAAAiC,MAAA,GAAAjC,CAAA;UACA,IAAAiC,MAAA;YACAhG,GAAA,CAAAiG,IAAA,CAAAD,MAAA,CAAAE,CAAA,EAAAF,MAAA,CAAAG,CAAA,EAAAH,MAAA,CAAA7F,KAAA,EAAA6F,MAAA,CAAA5F,MAAA;YACA;YACAJ,GAAA,CAAAoG,QAAA,CAAAJ,MAAA,CAAA5J,IAAA,UAAA4J,MAAA,CAAAK,UAAA,SAAAL,MAAA,CAAAE,CAAA,GAAAF,MAAA,CAAA7F,KAAA,MAAA6F,MAAA,CAAAG,CAAA;YACAnG,GAAA,CAAAsG,MAAA;UACA;QACA;QACA;QACA;MACA;MACA;MACA,SAAA/I,qBAAA,KAAAC,SAAA;QACA;QACAoC,aAAA,MAAArC,qBAAA;MACA;MACA;MACA,IAAAgJ,WAAA;MACA,IAAAC,kBAAA;MACA,IAAAzC,CAAA;MACA,KAAAxG,qBAAA,GAAAkJ,WAAA;QACA1C,CAAA;QACA;QACA,UAAAnB,MAAA,CAAA8D,MAAA,MAAA3C,CAAA,GAAAyC,kBAAA;UACAzC,CAAA;UACA/D,GAAA,CAAAE,SAAA,OAAAL,MAAA,CAAAM,KAAA,EAAAN,MAAA,CAAAO,MAAA;UACAJ,GAAA,CAAA+F,SAAA;UACA/F,GAAA,CAAAiD,WAAA;UACAjD,GAAA,CAAAkD,IAAA;UACAlD,GAAA,CAAAmD,SAAA;UACAnD,GAAA,CAAAoD,YAAA;UACApD,GAAA,CAAAqD,SAAA;QACA;QACA;QACA,IAAAsD,gBAAA,GAAA1C,IAAA,CAAAC,KAAA,MAAAtB,MAAA,CAAAgE,WAAA;QACA;QACA,IAAAtD,MAAA,CAAAc,GAAA,CAAAuC,gBAAA;UACA5C,CAAA;UACA/D,GAAA,CAAAE,SAAA,OAAAL,MAAA,CAAAM,KAAA,EAAAN,MAAA,CAAAO,MAAA;UACAJ,GAAA,CAAA+F,SAAA;UACA/F,GAAA,CAAAiD,WAAA;UACAjD,GAAA,CAAAkD,IAAA;UACAlD,GAAA,CAAAmD,SAAA;UACAnD,GAAA,CAAAoD,YAAA;UACApD,GAAA,CAAAqD,SAAA;UACA;UACA,IAAAwD,aAAA,GAAAvD,MAAA,CAAA5E,GAAA,CAAAiI,gBAAA,EAAAG,GAAA,WAAAtD,IAAA;YAAA,OAAAA,IAAA,CAAAuD,QAAA;UAAA,GAAAC,MAAA,WAAAtB,CAAA,EAAA3B,CAAA,EAAA5E,CAAA;YAAA,OAAAA,CAAA,CAAA8H,OAAA,CAAAvB,CAAA,MAAA3B,CAAA;UAAA;UACA;UACA8C,aAAA,CAAAxI,OAAA,WAAA0F,CAAA;YACA;YACA;YACA,IAAAmD,KAAA,GAAA5D,MAAA,CAAA5E,GAAA,CAAAiI,gBAAA,EAAAK,MAAA,WAAAG,GAAA;cAAA,OAAAA,GAAA,CAAAJ,QAAA,KAAAhD,CAAA;YAAA;YACAmD,KAAA,CAAA7I,OAAA,WAAA2H,MAAA;cACA,IAAAA,MAAA;gBACAhG,GAAA,CAAAiG,IAAA,CAAAD,MAAA,CAAAE,CAAA,EAAAF,MAAA,CAAAG,CAAA,EAAAH,MAAA,CAAA7F,KAAA,EAAA6F,MAAA,CAAA5F,MAAA;gBACA;gBACAJ,GAAA,CAAAoG,QAAA,CAAAJ,MAAA,CAAA5J,IAAA,UAAA4J,MAAA,CAAAK,UAAA,SAAAL,MAAA,CAAAE,CAAA,GAAAF,MAAA,CAAA7F,KAAA,MAAA6F,MAAA,CAAAG,CAAA;cACA;YACA;UACA;UACAnG,GAAA,CAAAsG,MAAA;QACA;MACA,EAAAzH,IAAA,QAAA0H,WAAA;IACA;IACA7G,SAAA,WAAAA,UAAA;MACA,IAAAjC,UAAA,OAAAC,GAAA;MACA,SAAA0J,cAAAC,WAAA;QACA,IAAA5J,UAAA,CAAA2G,GAAA,CAAAiD,WAAA;UACA5J,UAAA,CAAAe,GAAA,CAAA6I,WAAA;YAAA,KAAAA,WAAA;YAAA,KAAA5J,UAAA,CAAAiB,GAAA,CAAA2I,WAAA,EAAAlB,CAAA;UAAA;QACA;UACA1I,UAAA,CAAAe,GAAA,CAAA6I,WAAA;YAAA,KAAAA,WAAA;YAAA;UAAA;QACA;MACA;MACA,IAAApJ,OAAA,QAAAhB,kBAAA;MACAgB,OAAA,CAAAI,OAAA,WAAAC,MAAA;QACA;QACA,IAAA+I,WAAA,GAAApD,IAAA,CAAAC,KAAA,CAAA5F,MAAA,CAAAiF,SAAA;QACA,SAAA5F,YAAA;UACA;UACA,IAAAW,MAAA,CAAAG,YAAA,UAAAd,YAAA;YACAyJ,aAAA,CAAAC,WAAA;UACA;QACA,OACA;UACA;UACA;UACAD,aAAA,CAAAC,WAAA;QACA;MACA,EAAAxI,IAAA;MACA;MACA,IAAAyI,kBAAA,OAAA5J,GAAA,CAAAqB,kBAAA,CAAAtB,UAAA,CAAAuB,OAAA,IAAAC,KAAA,GAAAC,IAAA,WAAAC,CAAA,EAAAC,CAAA;QAAA,OAAAD,CAAA,MAAAC,CAAA;MAAA;MACA,IAAAmI,WAAA,GAAAC,KAAA,CAAAC,IAAA,CAAAH,kBAAA,CAAAI,MAAA;MACA,KAAAC,MAAA,CAAAC,MAAA,qBAAAL,WAAA;MACA,KAAAI,MAAA,CAAAC,MAAA,6BAAAjK,YAAA;IACA;EACA;AACA","ignoreList":[]}]}